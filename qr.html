<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>QR with logo (robust)</title>
<style>
  body { font-family: system-ui, Arial; padding: 20px; }
  #preview { margin-top: 12px; }
  svg { max-width: 100%; height: auto; display:block; }
  canvas { display:block; max-width:100%; height:auto; }
  button { margin-right:8px; }
</style>
</head>
<body>
  <h3>Generate QR (SVG with embedded logo) â€” test</h3>

  <label>Target URL</label>
  <input id="url" value="https://etesng.github.io/interest" style="width:100%">

  <label>Logo path / URL (same origin recommended)</label>
  <input id="logo" value="assets/Logo.png" style="width:100%">

  <label>QR size (px)</label>
  <input id="size" type="number" value="600">

  <label>Logo ratio (0.15 = 15%)</label>
  <input id="ratio" type="number" step="0.01" value="0.15">

  <div style="margin-top:10px">
    <button id="gen">Generate SVG</button>
    <button id="pngbtn">Generate PNG (fallback)</button>
    <button id="download" disabled>Download SVG</button>
  </div>

  <div id="preview"></div>

  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <script>
  // Helper: fetch image and convert to data URL
  async function imageToDataURL(url) {
    try {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error('fetch failed ' + res.status);
      const blob = await res.blob();
      return await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    } catch (err) {
      console.warn("imageToDataURL failed:", err);
      // fallback: return original url (may be blocked by CORS)
      return url;
    }
  }

  document.getElementById('gen').addEventListener('click', async () => {
    const url = document.getElementById('url').value.trim();
    const logoPath = document.getElementById('logo').value.trim();
    const size = parseInt(document.getElementById('size').value, 10) || 400;
    const ratio = parseFloat(document.getElementById('ratio').value) || 0.15;
    const ecl = 'H'; // highest error correction

    if (!url) return alert('Enter URL');

    // generate SVG string for QR (high ECL)
    const svgString = await new Promise((resolve, reject) => {
      QRCode.toString(url, { type: 'svg', width: size, errorCorrectionLevel: ecl }, (err, svg) => {
        if (err) reject(err); else resolve(svg);
      });
    });

    // try convert logo to base64/dataURL (best)
    let logoData = null;
    if (logoPath) {
      logoData = await imageToDataURL(logoPath);
    }

    // parse SVG and insert logo
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, "image/svg+xml");
    const svgEl = doc.querySelector('svg');

    // ensure viewBox exists
    let vb = svgEl.getAttribute('viewBox');
    let vbW = size, vbH = size;
    if (vb) {
      const p = vb.split(/\s+/).map(Number);
      if (p.length === 4) { vbW = p[2]; vbH = p[3]; }
    } else {
      svgEl.setAttribute('viewBox', `0 0 ${size} ${size}`);
      vbW = size; vbH = size;
    }

    // compute logo size & center
    const logoSize = Math.round(vbW * ratio);
    const cx = Math.round(vbW / 2);
    const cy = Math.round(vbH / 2);
    const r = Math.round(logoSize / 2);
    const padding = Math.round(logoSize * 0.12); // white padding around logo

    if (logoData) {
      // create white rounded rectangle / circle behind logo for contrast
      // use rounded rect with rx to match logo shape; circle works too
      const rect = doc.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute('x', cx - r - padding);
      rect.setAttribute('y', cy - r - padding);
      rect.setAttribute('width', (r*2) + padding*2);
      rect.setAttribute('height', (r*2) + padding*2);
      rect.setAttribute('rx', Math.round((r*2 + padding*2) * 0.12));
      rect.setAttribute('fill', '#fff');
      rect.setAttribute('stroke', 'none');
      rect.setAttribute('opacity', '1');

      // create image tag
      const img = doc.createElementNS("http://www.w3.org/2000/svg","image");
      img.setAttribute('x', cx - r);
      img.setAttribute('y', cy - r);
      img.setAttribute('width', r*2);
      img.setAttribute('height', r*2);
      img.setAttribute('preserveAspectRatio', 'xMidYMid meet');

      // use href (xlink namespace sometimes needed for older browsers)
      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', logoData);
      img.setAttribute('href', logoData);

      // Append the white background first then logo so logo appears on top
      svgEl.appendChild(rect);
      svgEl.appendChild(img);
    } else {
      console.warn('Logo not available; SVG will be without logo.');
    }

    // serialize SVG
    const finalSVG = new XMLSerializer().serializeToString(svgEl);

    // show preview
    const preview = document.getElementById('preview');
    preview.innerHTML = '';
    const wrapper = document.createElement('div');
    wrapper.innerHTML = finalSVG;
    preview.appendChild(wrapper);

    // enable download
    const blob = new Blob([finalSVG], { type: 'image/svg+xml;charset=utf-8' });
    const blobUrl = URL.createObjectURL(blob);
    const dl = document.getElementById('download');
    dl.disabled = false;
    dl.onclick = () => {
      const a = document.createElement('a');
      a.href = blobUrl;
      a.download = 'qr-with-logo.svg';
      document.body.appendChild(a);
      a.click();
      a.remove();
    };

    // Quick tester suggestion: also generate PNG fallback (uncomment if you want)
  });

  // PNG fallback using canvas: draw QR on canvas then draw logo on top
  document.getElementById('pngbtn').addEventListener('click', async () => {
    const url = document.getElementById('url').value.trim();
    const logoPath = document.getElementById('logo').value.trim();
    const size = parseInt(document.getElementById('size').value, 10) || 600;
    const ratio = parseFloat(document.getElementById('ratio').value) || 0.15;

    const canvas = document.createElement('canvas');
    canvas.width = size; canvas.height = size;
    document.getElementById('preview').innerHTML = '';
    document.getElementById('preview').appendChild(canvas);
    try {
      // draw QR on canvas
      await new Promise((resolve, reject) => {
        QRCode.toCanvas(canvas, url, { width: size, errorCorrectionLevel: 'H' }, (err) => {
          if (err) reject(err); else resolve();
        });
      });

      // draw logo on center (if available)
      try {
        const dataUrl = await imageToDataURL(logoPath);
        const img = new Image();
        img.onload = () => {
          const ctx = canvas.getContext('2d');
          const logoW = Math.round(size * ratio);
          const logoH = logoW * (img.height / img.width);
          const x = (size - logoW) / 2;
          const y = (size - logoH) / 2;

          // white rounded rect behind logo
          const pad = Math.round(logoW * 0.12);
          ctx.fillStyle = '#ffffff';
          roundRect(ctx, x - pad, y - pad, logoW + pad*2, logoH + pad*2, Math.round(logoW*0.08), true, false);

          // draw logo
          ctx.drawImage(img, x, y, logoW, logoH);

          // make PNG download link
          const pngData = canvas.toDataURL('image/png');
          const a = document.createElement('a');
          a.href = pngData; a.download = 'qr-with-logo.png';
          a.textContent = 'Download PNG';
          document.getElementById('preview').appendChild(a);
        };
        img.onerror = (e) => console.warn('logo image load failed', e);
        img.src = dataUrl;
      } catch (e) {
        console.warn('logo fetching or drawing failed', e);
      }
    } catch (err) {
      alert('QR canvas generation failed: ' + err);
    }
  });

  // small helper: draw rounded rect on canvas
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y,   x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x,   y + h, r);
    ctx.arcTo(x,   y + h, x,   y,   r);
    ctx.arcTo(x,   y,   x + w, y,   r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }
  </script>
</body>
</html>
